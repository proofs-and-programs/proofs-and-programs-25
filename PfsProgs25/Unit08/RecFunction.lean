import Mathlib
/-!
## Recursion and Induction on (Indexed) Inductive Types

We have been using `match` expressions to define functions on inductive types. In this file, we will see how to define functions using recursion and induction principles. These principles are automatically generated by Lean when an inductive type is defined, with functions like `Nat.rec` automatically introduced.
-/
/-
inductive Nat : Type
number of parameters: 0
constructors:
Nat.zero : ℕ
Nat.succ : ℕ → ℕ
-/
#print Nat

/-
inductive List.{u} : Type u → Type u
number of parameters: 1
constructors:
List.nil : {α : Type u} → List α
List.cons : {α : Type u} → α → List α → List α
-/
#print List

/-
protected inductive Nat.le : ℕ → ℕ → Prop
number of parameters: 1
constructors:
Nat.le.refl : ∀ {n : ℕ}, n.le n
Nat.le.step : ∀ {n m : ℕ}, n.le m → n.le m.succ
-/
#print Nat.le

/-!
The function that allows us to define (dependent) functions by recursion and prove results by induction on the natural numbers is `Nat.rec`. It has the following type:
-/
/-
⊢ {motive : ℕ → Sort u} → motive Nat.zero → ((n : ℕ) → motive n → motive n.succ) → (t : ℕ) → motive t
-/
#check Nat.rec
/-!
The `motive` should really be *motif*, i.e., a template. To define functions to say `Nat`, the motive is the constant function with value `Nat`. We will first focus on this case. The motive is constant for *recursive definitions* of (non dependent) functions.
-/

/-
Nat.rec : ℕ → (ℕ → ℕ → ℕ) → ℕ → ℕ
-/
#check Nat.rec (motive := fun _ => Nat)
/-!
What the above says is that to define a function `f` recusively, the data we need is:
1. The value of `f` at `0`.
2. The function `f` at `n + 1` given `n` and the value `f n` of `f` at `n`.
-/
def fctrl : ℕ → ℕ :=
  Nat.rec 1 (fun n fn => (n + 1) * fn)

#eval fctrl 5 -- 120

/-
fctrl : ℕ → ℕ
-/
#check fctrl

def fctrl' : ℕ → ℕ :=
  Nat.rec (motive := fun _ => ℕ) 1 (fun n fn => (n + 1) * fn)

/--
error: failed to synthesize
  OfNat ((fun x ↦ String) Nat.zero) 1
numerals are polymorphic in Lean, but the numeral `1` cannot be used in a context where the expected type is
  (fun x ↦ String) Nat.zero
due to the absence of the instance above
Additional diagnostic information may be available using the `set_option diagnostics true` command.
---
error: failed to synthesize
  HMul ℕ ((fun x ↦ String) n) ((fun x ↦ String) n.succ)
Additional diagnostic information may be available using the `set_option diagnostics true` command.
-/
#guard_msgs in
def stringFromNat  :=
  Nat.rec (motive := fun _ => String) 1 (fun n fn => (n + 1) * fn)

/-
Nat.rec : Bool → (ℕ → Bool → Bool) → ℕ → Bool
-/
#check Nat.rec (motive := fun _ => Bool)

set_option linter.unusedVariables false in
def even : ℕ → Bool :=
  Nat.rec true (fun n p => !p)

/-!
When a function `f` is defined using `Nat.rec`, some definitional equalities are automatically generated. For example, the following is true by definition:
-/
theorem fctrl_zero : fctrl 0 = 1 := rfl

theorem fctrl_succ (n : ℕ) :
  fctrl (n + 1) = (n + 1) * fctrl n := rfl

/-!
We can write the definitional equalities in a general form.
-/
theorem Nat.recFn_zero {α : Type u}
    (zeroData : α) (stepData : ℕ → α → α) :
  Nat.rec zeroData stepData 0 = zeroData := rfl

theorem Nat.recFn_succ {α : Type u}
    (zeroData : α) (stepData : ℕ → α → α) (n : ℕ) :
  Nat.rec zeroData stepData (n + 1) = stepData n (Nat.rec zeroData stepData n) := rfl

/-!
We see next recursive definitions of dependent functions. The motive is not constant in this case.

Concretely, we define:

* A family of types `Tuple : ℕ → Type` such that `Tuple n` is the type of `n`-tuples of natural numbers.
* The dependent function `tuple : (n : ℕ) → Tuple (n + 1)` such that `tuple n` is the `n+1`-tuple of natural numbers `(n, ..., 1, 0)`.
-/

def Tuple : ℕ → Type
  | 0 => Unit
  | n + 1 => ℕ × Tuple n

theorem tuple1Type :  Tuple 1 = (ℕ × Unit) := rfl

theorem tuple2Type: Tuple 2 = (ℕ × (ℕ × Unit)) := rfl

/-!
Note that `×` and `→` are *right-associative*. So, `ℕ × ℕ × Unit` is the same as `ℕ × (ℕ × Unit)`.
-/
theorem tuple2Type': Tuple 2 = (ℕ × ℕ × Unit) := rfl

#check (1, (2, 3)) -- ℕ × ℕ × ℕ

#check ((1, 2), 3) -- (ℕ × ℕ) × ℕ

#check (1, 2, 3) -- ℕ × ℕ × ℕ

def tuple : (n : ℕ) → Tuple (n + 1)
  | 0 => (0, ())
  | n + 1 => (n + 1, tuple n)

/-
(5, 4, 3, 2, 1, 0, PUnit.unit)
-/
#eval tuple 5

#check tuple 5 -- Tuple 6

#check () -- Unit

/-
Nat.rec : Tuple (Nat.zero + 1) → ((n : ℕ) → Tuple (n + 1) → Tuple (n.succ + 1)) → (t : ℕ) → Tuple (t + 1)
-/
#check Nat.rec (motive := fun n => Tuple (n + 1))

def tuple' : (n : ℕ) → Tuple (n + 1) :=
  Nat.rec (0, ()) (fun n tn => (n + 1, tn))

/-!
The recursive definition of `tuple'` satisfies the following definitional equalities.
-/
theorem tuple'_zero : tuple' 0 = (0, ()) := rfl

theorem tuple'_succ (n : ℕ) :
  tuple' (n + 1) = (n + 1, tuple' n) := rfl

/-
structure Vector.{u} (α : Type u) (n : ℕ) : Type u
number of parameters: 2
parents:
  Vector.toArray : Array α
fields:
  Array.toList : List α
  Vector.size_toArray : self.size = n
constructor:
  Vector.mk.{u} {α : Type u} {n : ℕ} (toArray : Array α) (size_toArray : toArray.size = n) : Vector α n
resolution order:
  Vector, Array
-/
#print Vector
